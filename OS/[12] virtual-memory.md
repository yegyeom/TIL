# 가상 메모리

- 물리 메모리 크기의 한계를 극복하기 위해 나온 기술
- 예를 들어, 100MB 메모리 크기에서 200MB 크기의 프로세스를 수행할 수 있도록 하는 것

## Demand Paging (요구 페이징)

- **현재 필요한 (요구 되는) 페이지만 메모리에 올리는 것**
- I/O 양의 감소
- 메모리 사용량 감소
- 빠른 응답 시간
- 더 많은 사용자 수용
- Valid bit 사용
  - 현재 메모리에 페이지가 있는지 없는지 나타내는 비트
  - 처음에는 모든 페이지 엔트리가 invalid로 초기화

## Page fault (페이지 부재)

- **요청한 주소가 메모리에 올라와 있지 않은 경우 발생**
- **즉, 페이지 테이블의 valid bit 값이 0인 경우**
- Page fault 발생 시
  1. 해당 페이지가 메모리에 있는지 valid bit를 확인
  2. valid bit가 0이라면 CPU에 인터럽트 신호를 보내어 운영체제 내부 해당 ISR(Interrupt Service Routine)로 점프한다.
  3. 해당 ISR에서 backing store(디스크)를 탐색하여 해당 프로세스의 페이지를 찾는다.
  4. 해당 페이지를 비어있는 프레임에 할당한다.
  5. 페이지 테이블을 갱신한다. (프레임 번호 설정, valid bit 1로 변경)
  6. 다시 명령어로 돌아가서 실행한다.

## Page Replacement (페이지 교체)

- 요구된 페이지를 메모리에 올리려는데 메모리가 가득 찬 경우 수행됨

## Page Replacement Algorithm

- 목표: page-fault rate 최소화

1. **Optimal Algorithm (Min Algorithm)**
   - 가장 먼 미래에 참조되는 페이지를 교체
   - 실제 사용은 불가능함 (미래를 안다는 가정)
   - 비교 연구 목적을 위해 사용됨
2. **FIFO Algorithm**
   - 가장 먼저 들어온 페이지를 교체
   - 직관적으로 생각할 때 프레임의 수가 많아질수록 페이지 결함의 횟수는 감소
     - FIFO Anomaly: 실제로 그렇게 되지 않는 현상이 나타날 수 있다.
3. **LRU Algorithm (Least Recently Used)**
   - 가장 오래전에 참조된 페이지를 교체
   - 시간 지역성 고려: 최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질
   - 참조된 페이지 시간을 기록해야 하므로 막대한 오버헤드 발생
4. **LFU Algorithm (Least Frequently Used)**
   - 참조 횟수가 가장 적은 페이지를 교체
   - 가장 최근에 불러온 페이지가 교체될 수 있다.
   - 막대한 오버헤드 발생
5. **Clock Algorithm**
   - 하드웨어의 도움을 받아서 페이지를 교체
   - 최근에 사용하지 않은 페이지 교체 (LRU를 근사한 알고리즘)
   - LRU/LFU 대신 실제 사용되는 알고리즘
   - 각 페이지마다 두 개의 비트가 사용됨
     - 참조 비트 (Reference bit): 페이지가 참조되지 않았을 때 0, 호출되었을 때 1
     - 변형 비트 (Modified bit): 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때 1
   - 우선순위: 참조 비트 > 변형 비트

## Swapping

- 주기억장치에 적재한 하나의 프로세스와 보조 기억 장치에 적재한 다른 프로세스의 메모리를 교체하는 기법
- 프로세스 단위로 교체
- 이후에 가상 메모리 관리 방법인 페이징 기법으로 발전한 것

**`스와핑은 프로세스 단위로 교체하지만 VMM은 paging 단위로 교체`**

---

## Reference

- https://developyo.tistory.com/217?category=752792
- https://velog.io/@codemcd/운영체제OS-15.-가상메모리
